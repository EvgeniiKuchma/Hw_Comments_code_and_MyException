#include <iostream>
#include <utility>//библиотека для работы с классом pair
#include <vector>
#include <unordered_map>
#include <tuple>
#include <new>
#include <limits>
#include "MyException.h"
///////////////////////////////////++++++++++ + NEW TASK ++++++++++++
class DataManager//создаем класс
{
public://создаем мдификатор доступа: доступ открыт всем, кто видит определение данного класса
	int mostPopChedKey()//создаем функцию без параметров с типом данных int 
	{
		std::unordered_map<int, int> keyAutom;//создаем структуру(STL контейнер) для записи в нее пар <уникальный ключ, (елемент записанный в векторе std::vector<int>
		//хотя бы 1 раз) значение(количество повторений элемента, выше упомянутого, в векторе)> с типом данных для обоих значениq пар, хранящихся в нашей unordered_map, 
		// определенных как <int, int>, а так же создаем обьекть структуры в виде перменной локальной переменной keyAutom, с помощью которой в дальйнейшем будем взаимодействовать с данной структурой
		for (size_t i = 0; i < _key.size(); i++)//запускаем цикл for для пербора элементов записанныч в векторе std::vector<int> при этом тип переменной i определяем как size_t
		//что значит - беззнаковый целый тип, предназначенный для представления размера любого объекта в памяти (включая массивы) в конкретной реализации,а условия выполнения цикла 
		//ограничиваем методом .size() который возвращает количество элементов в векторе.
		{
			const auto& [it, isInserted] = keyAutom.insert({ _key[i], 1 });//с помощью создания перменных с авто оапредеяемым типом данных и квадратными скобками в качестве определителя наличия пары
			//достаем из вектора ключ пытаемся вставить в мап. в [it, isInsert] возвращает функция insert <итератор на элемент который мешает сделать инсерт(или инсерт которого был выполнен, bool значение удалось или нет выполнить insert>
			// при этом фигурными скобками внутри крыглых мы обозначаем наличие пары передаваемой в переменные, а указание на элементы в паре метода инсерт происходит по итератору, именно через перменную _key(обозначающую обращение к вектору) 
			// и [i](указывающую на индекс конкретного элемента) из вектора мы записываем (оператор квадратные скобки разворачивает пару it - итератор на значения пары ({key[i],1})  и bool значение)
			//данные в [it, isInsert]
			if (!isInserted)//прописываем условие при котором элементы из вектора будут записаны в unordered_map, !inInsert интерпритируется так - если вставка не произошла
			{
				auto value = it->second;// в случае верности выше указанного условия мы создаем перменную value с типом данных auto и записываем в нее значение из пары insert в нашем случае 1
				value++;//после чего увеличиваем это значение на единицу 1 + 1
				keyAutom[_key[i]] = value;//обращаемся через квадратные скобки и перменную keyAuto, так как фунция insert({}) не позволит вставить а [] гарантированно вставят значения, к паре в методе insrert находящейся в unordered_map и перпесываем значение
				//втророго элемента пары
			}
		} 
		std::pair<int, int> key_biggestValue = { 0,0 };//создаем структуру pair с типом данными ключа и значения int, для этой структуры создаем переменную обращения к ней key_biggestValue и  ининциализируем ее нулевыми значениями для понимания того что 
		//в данную структуры будет попытка записать значения из пустой unordered_map (при этом резулбатом работы фунции вернется 0 0 в консоли). Цель создания данной структуры размещеать в ней найденные в наиболле часто встречающийся в unordered_map. Также мы не ппердавли в структуру pair keyAutom.begin() и keyAutom.end()
		//так это может привести к  критической ошибке в случае если unordered_map будет пустой
		for (std::unordered_map<int, int>::const_iterator it = keyAutom.begin(); it != keyAutom.end(); it++)//запускаем цикл для пербора пар находящихся в unordered_map, напомню что на данный момент в ней содержаться уникальные ключи 
	//которыми являются элементы хотя бы раз встречающися в векторе а так же значения этих ключей представляющие из себя количество повторений того или иного элеменета в векторе 
		{
			if (key_biggestValue.second < it->second)//проверка условия при котором пара из unordered_map должна иметь большее значение второго элемента нежели аналогичное значение елемента пары структуры pair к торой мы обращаемя через 
				//перменную key_biggestValue и метод second который содержит указатель на 2й элемент пары
				key_biggestValue = std::make_pair(it->first, it->second);//при соблюденнии данного условия записываем в структуру pair с помощью обьекта key_biggestValue и шаблонной функции std::make_pair которая позволяет 
			//создать пару значений без явной записи типов. При	этом используя итератор  it который указывает на первое и втрое поле записываемой пары
		}
		return key_biggestValue.first;//в конце возвращаем ключ наибольшим значением 2 го его элемента который, напомню, является количеством повторений ключа в векторе
	}
private:
	std::vector<int> _key = { 1,1,2,2,2,4,2,6,7,7,7,2 };//тот самый столько раз мною упомянутый вектор
};
///////////////////////////////////+++++++++++ NEW TASK ++++++++++++
MyException  r;
template<typename T>
T MyExceptionFunc(T a, T b)
{
	if (b == 0) 
	{
		throw  r;
	}
	return a / b;
}
///////////////////////////////////+++++++++++ NEW TASK ++++++++++++

int main()
{
//////////////////////////////////+++++++++++ NEW TASK++++++++++++
DataManager dm;//создание обьекта класса для взаимодействия с ним 
std::cout << dm.mostPopChedKey() << std::endl;//вызов фунции и вывод результата ее работы в консол  через дескриптор std::cout
//////////////////////////////////+++++++++++ NEW TASK++++++++++++
std::cout << "+++++++++++ /NEW TASK/ ++++++++++++\n" << std::endl;
int n ;
std::cout << "pls enter the biggest number who you know" << std::endl;
try
{
	do
	{
		std::cin >> n;
		 int *list = new int[n * 10000000000];
		std::cout << "Nice number!!!" << std::endl;
		delete[] list;
	} while (n > std::numeric_limits<int>::max());
}
catch (const std::bad_alloc& e) 
{
std::cout << "Allocation failed: " << e.what() << '\n';
}
//////////////////////////////////+++++++++++ NEW TASK++++++++++++
std::cout << "\n+++++++++++ /NEW TASK/ ++++++++++++\n" << std::endl;
try
{ 
	double a, b;
	do
	{
	std::cout << "\nPlease enter the numbers with which you want to perform the division operation: ";
	std::cin >>  a;
	std::cout << "\nPlease enter the next numbers: "; 
	std::cin >> b;
	std::cout <<"\nResult you division: " << MyExceptionFunc(a, b) << std::endl;;
	} while (b != 0);
}
catch ( MyException& e1)
{
	std::cerr << e1.what();
}
return 0;
}