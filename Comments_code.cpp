#include <iostream>
#include <utility>//библиотека для работы с классом pair
#include <vector>
#include <unordered_map>
#include <tuple>

class DataManager//создаем класс
{
public://создаем мдификатор доступа: доступ открыт всем, кто видит определение данного класса
	int mostPopChedKey()//создаем функцию без параметров с типом данных int 
	{
		std::unordered_map<int, int> keyAutom;//создаем структуру(STL контейнер) для записи в нее пар <уникальный ключ, (елемент записанный в векторе std::vector<int>
		//хотя бы 1 раз) значение(количество повторений элемента, выше упомянутого, в векторе)> с типом данных для обоих значениq пар, хранящихся в нашей unordered_map, 
		// определенных как <int, int>, а так же создаем обьекть структуры в виде перменной локальной переменной keyAutom, с помощью которой в дальйнейшем будем взаимодействовать с данной структурой
		for (size_t i = 0; i < _key.size(); i++)//запускаем цикл for для пербора элементов записанныч в векторе std::vector<int> при этом тип переменной i определяем как size_t
		//что значит - беззнаковый целый тип, предназначенный для представления размера любого объекта в памяти (включая массивы) в конкретной реализации,а условия выполнения цикла 
		//ограничиваем методом .size() который возвращает количество элементов в векторе.
		{
			const auto& [it, isInserted] = keyAutom.insert({ _key[i], 1 });//с помощью создания перменных с авто оапредеяемым типом данных и квадратными скобками в качестве определителя наличия пары
			//достаем из вектора ключ пытаемся вставить в мап. в [it, isInsert] возвращает функция insert <указатель на элемент который мешает сделать инсерт(или инсерт которого был выполнен, bool значение удалось или нет выполнить insert>
			// при этом фигурными скобками внутри крыглых мы обозначаем наличие пары передаваемой в переменные, а указание на элементы в паре метода инсерт происходит по ссылке, именно через перменную _key(обозначающую обращение к вектору) 
			// и [i](указывающую на индекс конкретного элемента) из вектора мы записываем 
			//данные в [it, isInsert]
			if (!isInserted)//прописываем условие при котором элементы из вектора будут записаны в unordered_map, !inInsert интерпритируется так - если вставка не произошла
			{
				auto value = it->second;// в случае верности выше указанного условия мы создаем перменную value с типом данных auto и записываем в нее значение из пары insert в нашем случае 1
				value++;//после чего увеличиваем это значение на единицу 1 + 1
				keyAutom[_key[i]] = value;//обращаемся через квадратные скобки и перменную keyAuto, так как фунция insert({}) не позволит вставить а [] гарантированно вставят значения, к паре в методе insrert находящейся в unordered_map и перпесываем значение
				//втророго элемента пары
			}
		} 
		std::pair<int, int> key_biggestValue = { 0,0 };//создаем структуру pair с типом данными ключа и значения int, для этой структуры создаем переменную обращения к ней key_biggestValue и  ининциализируем ее нулевыми значениями для из 
		//бежания ошибок при которых в данную структуры будет попытка записать значения из пустой unordered_map. Цель создания данной структуры размещеать в ней найденные в наиболле часто встречающийся в unordered_map
		for (std::unordered_map<int, int>::const_iterator it = keyAutom.begin(); it != keyAutom.end(); it++)//запускаем цикл для пербора пар находящихся в unordered_map, напомню что на данный момент в ней содержаться уникальные ключи 
	//которыми являются элементы хотя бы раз встречающися в векторе а так же значения этих ключей представляющие из себя количество повторений того или иного элеменета в векторе 
		{
			if (key_biggestValue.second < it->second)//проверка условия при котором пара из unordered_map должна иметь большее значение второго элемента нежели аналогичное значение елемента пары структуры pair к торой мы обращаемя через 
				//перменную key_biggestValue и метод second который содержит указатель на 2й элемент пары
				key_biggestValue = std::make_pair(it->first, it->second);//при соблюденнии данного условия записываем в структуру pair с помощью обьекта key_biggestValue и шаблонной функции std::make_pair которая позволяет 
			//создать пару значений без явной записи типов. При	этом используя итератор  it который указывает на первое и втрое поле записываемой пары
		}
		return key_biggestValue.first;//в конце возвращаем ключ наибольшим значением 2 го его элемента который, напомню, является количеством повторений ключа в векторе
	}
private:
	std::vector<int> _key = { 1,1,2,2,2,4,2,6,7,7,7,2 };//тот самый столько раз мною упомянутый вектор

};
int main()
{
DataManager dm;//создание обьекта класса для взаимодействия с ним 
std::cout << dm.mostPopChedKey() << std::endl;//вызов фунции и вывод результата ее работы в консол  через пространство имен std


return 0;
}